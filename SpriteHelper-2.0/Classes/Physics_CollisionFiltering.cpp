//
//  Physics_CollisionFiltering.cpp
//  SpriteHelper2-TestCases
//
//  Created by Bogdan Vladu on 5/22/13.
//
//

#include "Physics_CollisionFiltering.h"
#include "HelloWorldScene.h"
#include "GameDevHelper.h"
using namespace cocos2d;

Physics_CollisionFiltering::~Physics_CollisionFiltering()
{
    GHDirector::sharedDirector()->setPhysicalWorld(NULL);
    delete world;
    world = NULL;    
}

Physics_CollisionFiltering::Physics_CollisionFiltering()
{
}

CCScene* Physics_CollisionFiltering::scene()
{
	CCScene * scene = NULL;
	do
	{
		// 'scene' is an autorelease object
		scene = CCScene::create();
		CC_BREAK_IF(! scene);
        
		// 'layer' is an autorelease object
		Physics_CollisionFiltering *layer = Physics_CollisionFiltering::create();
		CC_BREAK_IF(! layer);
        
		// add layer as a child to scene
		scene->addChild(layer);
	} while (0);
    
	// return the scene
	return scene;
}

std::string Physics_CollisionFiltering::initTest()
{
    mouseJoint = NULL;
    
    CCSize s = CCDirector::sharedDirector()->getWinSize();
    
#if 1
    // Use batch node. Faster
    //when using batches - load a batch node using the generated image
    batchNodeParent = CCSpriteBatchNode::create("physicsCollisionTestRobots_robots.png", 100);
    this->addChild(batchNodeParent, 0);
#endif
    
    //load into the sprite frame cache the plist generated by SH
    CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFramesWithFile("physicsCollisionTestRobots_robots.plist");
    
    
    this->initPhysics();
    
    
    GHDebugDrawLayer* debugDraw = GHDebugDrawLayer::createDebugDrawLayerWithWorld(world);
    this->addChild(debugDraw, 1000);

    
    
    this->executeTestCodeAtPosition(ccp(s.width/2, s.height/2));
    
    this->scheduleUpdate();
    
    return "Tap screen to create sprites";
}

void Physics_CollisionFiltering::executeTestCodeAtPosition(CCPoint p)
{
    //set the current world you want to use when creating bodies
    //in case you have multiple worlds just set the coresponding world before creating the sprites
    //CAREFULL - when deleting the box2d world you should also pass NULL to this method
    GHDirector::sharedDirector()->setPhysicalWorld(world);
    
    //set your custom PTM_RATIO
    GHDirector::sharedDirector()->setPointToMeterRatio(PTM_RATIO);

    
    GHSprite* blueRobot1 = GHSprite::createWithSpriteFrameName("blueRobot");
    blueRobot1->setPosition(ccp(100,100));
    batchNodeParent->addChild(blueRobot1);
    
    GHSprite* blueRobot2 = GHSprite::createWithSpriteFrameName("blueRobot");
    blueRobot2->setPosition(ccp(200,100));
    batchNodeParent->addChild(blueRobot2);
    
    
    GHSprite* pinkRobot1 = GHSprite::createWithSpriteFrameName("pinkRobot");
    pinkRobot1->setPosition(ccp(100,200));
    batchNodeParent->addChild(pinkRobot1);
    
    GHSprite* pinkRobot2 = GHSprite::createWithSpriteFrameName("pinkRobot");
    pinkRobot2->setPosition(ccp(200,200));
    batchNodeParent->addChild(pinkRobot2);
    
    
    GHSprite* greenRobot1 = GHSprite::createWithSpriteFrameName("greenRobot");
    greenRobot1->setPosition(ccp(100,300));
    batchNodeParent->addChild(greenRobot1);
    
    GHSprite* greenRobot2 = GHSprite::createWithSpriteFrameName("greenRobot");
    greenRobot2->setPosition(ccp(200,300));
    batchNodeParent->addChild(greenRobot2);
}


void Physics_CollisionFiltering::initPhysics()
{
    CCSize s = CCDirector::sharedDirector()->getWinSize();
    
    b2Vec2 gravity;
    gravity.Set(0.0f, -10.0f);
    world = new b2World(gravity);
    
    // Do we want to let bodies sleep?
    world->SetAllowSleeping(true);
    
    world->SetContinuousPhysics(true);
    
    
    // Define the ground body.
    b2BodyDef groundBodyDef;
    groundBodyDef.position.Set(0, 0); // bottom-left corner
    
    // Call the body factory which allocates memory for the ground body
    // from a pool and creates the ground box shape (also from a pool).
    // The body is also added to the world.
    groundBody = world->CreateBody(&groundBodyDef);
    
    // Define the ground box shape.
    b2EdgeShape groundBox;
    
    // bottom
    
    groundBox.Set(b2Vec2(0,0), b2Vec2(s.width/PTM_RATIO,0));
    groundBody->CreateFixture(&groundBox,0);
    
    // top
    groundBox.Set(b2Vec2(0,s.height/PTM_RATIO), b2Vec2(s.width/PTM_RATIO,s.height/PTM_RATIO));
    groundBody->CreateFixture(&groundBox,0);
    
    // left
    groundBox.Set(b2Vec2(0,s.height/PTM_RATIO), b2Vec2(0,0));
    groundBody->CreateFixture(&groundBox,0);
    
    // right
    groundBox.Set(b2Vec2(s.width/PTM_RATIO,s.height/PTM_RATIO), b2Vec2(s.width/PTM_RATIO,0));
    groundBody->CreateFixture(&groundBox,0);
}

void Physics_CollisionFiltering::update(float dt)
{
	//It is recommended that a fixed time step is used with Box2D for stability
	//of the simulation, however, we are using a variable time step here.
	//You need to make an informed choice, the following URL is useful
	//http://gafferongames.com/game-physics/fix-your-timestep/
	
	int32 velocityIterations = 8;
	int32 positionIterations = 1;
	
	// Instruct the world to perform a single step of simulation. It is
	// generally best to keep the time step and iterations fixed.
	world->Step(dt, velocityIterations, positionIterations);
}


void Physics_CollisionFiltering::createMouseJointForTouchLocation(CCPoint point)
{
    if(groundBody == NULL)
        return;
    
    b2Body* ourBody = NULL;
    
    b2Vec2 locationInWorld = GH_POINT_TO_METERS(point);
    
    
    for (b2Body* b = world->GetBodyList(); b; b = b->GetNext())
    {
        if(b != groundBody)
        {
            b2Fixture* stFix = b->GetFixtureList();
            while(stFix != 0){
                
                if(stFix->TestPoint(locationInWorld))
                {
                    ourBody = b;
                    break;//exit for loop
                }
                stFix = stFix->GetNext();
            }
        }
    }
    
    if(ourBody == NULL)
        return;
    
    
    
    b2MouseJointDef md;
    md.bodyA = groundBody;
    md.bodyB = ourBody;
    
    
    md.target = locationInWorld;
    md.collideConnected = true;
    md.maxForce = 1000.0f * ourBody->GetMass();
    ourBody->SetAwake(true);
    
    if(mouseJoint){
        world->DestroyJoint(mouseJoint);
        mouseJoint = NULL;
    }
    
    mouseJoint = (b2MouseJoint *)world->CreateJoint(&md);
}

void Physics_CollisionFiltering::setTargetOnMouseJoint(CCPoint point)
{
    if(mouseJoint == 0)
        return;
    b2Vec2 locationWorld = b2Vec2(point.x/PTM_RATIO,
                                  point.y/PTM_RATIO);
    
    mouseJoint->SetTarget(locationWorld);
}

void Physics_CollisionFiltering::destroyMouseJoint(){
    if(mouseJoint){
        world->DestroyJoint(mouseJoint);
        mouseJoint = NULL;
    }
}


void Physics_CollisionFiltering::ccTouchesBegan(CCSet *pTouches, CCEvent *pEvent){
 
    CCTouch* touch = (CCTouch*)( pTouches->anyObject() );
    CCPoint location = touch->getLocationInView();
    location = CCDirector::sharedDirector()->convertToGL(location);
    this->createMouseJointForTouchLocation(location);
    
}
void Physics_CollisionFiltering::ccTouchesMoved(CCSet *pTouches, CCEvent *pEvent)
{
    CCTouch* touch = (CCTouch*)( pTouches->anyObject() );
    CCPoint location = touch->getLocationInView();
    location = CCDirector::sharedDirector()->convertToGL(location);
    this->setTargetOnMouseJoint(location);
}
void Physics_CollisionFiltering::ccTouchesEnded(CCSet *pTouches, CCEvent *pEvent)
{
    this->destroyMouseJoint();
}

void Physics_CollisionFiltering::ccTouchesCancelled(CCSet *pTouches, CCEvent *pEvent)
{
    this->destroyMouseJoint();
}

